{
	"research": [ 
		{
			"id": "causeandeffect",
			"title": "Climate Change and Severe Weather Events",
			"shorttitle": "Climate Change",
			"date": "Semester: Fall 2021",
			"course": "Course: Cause and Effect (Econometrics)",
			"partners": "Partner: Josh Y.",
			"image": "img/USWeatherDisastersChoropleth.gif",
			"short": "This econometrics project utilized Python regression analysis on large datasets to infer the relationship between rising temperatures (from global warming) on the number of severe weather events that occur.",
			"long": "The field of <b><a href='https://en.wikipedia.org/wiki/Econometrics'>econometrics</a></b> aims to use statistics as a means to finding causal relationships between things, if they exist. During my first semester of senior year, I took Cooper's \"Cause and Effects\" class, which covered the theory and application of econometrics. For my final project, I worked with a partner to find the relationship between climate change and severe weather events. Our data came in two parts: (1) <b><a href='https://www.fema.gov/openfema-data-page/disaster-declarations-summaries-v2'>FEMA data on severe weather events in the contiguous US</a></b> and (2) <b><a href='https://github.com/washingtonpost/data-2C-beyond-the-limit-usa'>per county average yearly US temperature data</a></b>; the datasets were combined and narrowed to the 1953 to 2019 range. We used various regression models, controlling for differences in location, time, and even lagged effects, to find a relationship between the rising temperature and the number of severe weather events. Ultimately, we concluded that there is a statistically significant effect of temperature on severe weather events, where there is an increase in severe weather events in response to rising temperatures (i.e. global warming), although we could confidently quantify this relationship. To perform the regression analyses, we used the <b><a href='https://www.statsmodels.org/stable/index.html#'>statsmodels</a></b> Python package. I also TA'd this class, assisting senior engineering students with using Python for the purposes of this course. My code for this class project can be found on GitHub <b><a href='https://github.com/jjacobowitz/SS340_Abdelwahed/tree/main/Project'>here</a></b>. My code for this class in general can be found <b><a href='https://github.com/jjacobowitz/SS340_Abdelwahed'>here</a></b>.",
			"image_description": "Shown: An animated choropleth of the per-year county disaster declarations in the contiguous US that I made in Python."
		},
		{
			"id": "sandia",
			"title": "Sandia National Laboratories NOMAD",
			"shorttitle": "Sandia National Labs",
			"date": "Dates: May 2021 - July 2021",
			"course": 0,
			"partners": "Mentor: N. Hubbard<br>Partners: L. Alqawasmi and J. Albelo-Cortes",
			"image": "img/EmpiricalModelofPunctureEnergyforMetalsPoster.png",
			"short": "I spent the summer of 2021 at Sandia National Laboratories as part of the Nonlinear Mechanics and Dynmaics (NOMDA) Research Institute researching material failure as a result of a probe puncturing the material. I ran FEA simulations and processed the data using my own custom Python scripts.",
			"long": "Seeking a formal research experience where I could use the FEA skills, I interned during the summer of 2021 at <b><a href='https://en.wikipedia.org/wiki/Sandia_National_Laboratories'>Sandia National Laboratories</a></b> (Sandia) as part of the <b><a href='https://www.sandia.gov/careers/career-possibilities/students-and-postdocs/internships-co-ops/institute-programs/nonlinear-mechanics-and-dynamics-research-institute-2/'>Nonlinear Mechanics and Dynamics (NOMAD) Research Institute</a></b>. There, I was one of eighteen students in the program and one of only six undergraduate students. As part of a group of three, I worked on simulating and characterizing the puncture energy of metals to generate an empirical model that could quickly calculate the approximate puncture energy of metals to enable safety measures for personnel and product during the manufacturing and transport of sensitive nuclear military equipment. The empirical equation we were using was previously developed by a Sandia employee, and in graduate school, I will also build on previous work, advancing the current knowledge of my field of study. During this internship, I used Sandia's in-house FEA software, <b><a href='https://www.sandia.gov/asc/advanced-simulation-and-computing/integrated-codes/'>Sierra and CUBIT</a></b>, and ran the simulations on their <b><a href='https://hpc.sandia.gov/'>high-performance computers</a></b>. My group and I investigated the effects of four parameters, resulting in 108 different model variations. To quickly generate the simulation files, I wrote a Python script, which drastically reduced the preprocessing my group and I needed to do. I also used Python to write a comprehensive post-processing script that used nonlinear least-squares regression to fit the simulation data with the empirical equation and created the plots for our internally published paper, which we presented to over 100 Sandia researchers. I also presented this work at the 10th <b><a href='https://www.usna.edu/NASEC/index.php'>Naval Academy Science and Engineering Conference</a></b> in November 2021 after being selected as the mechanical engineering representative by The Cooper Union Chair of the Mechanical Engineering Department. Click <b><a href='https://www.osti.gov/biblio/1817295'>here</a></b> for the link to the paper on OSTI.gov.",
			"image_description": "Shown: The poster I presented at the 10th Naval Academy Science and Engineering Conference in November 2021."
		},
		{
			"id": "springmasschaos",
			"title": "Spring-Mass Chaos",
			"shorttitle": "Spring-Mass Chaos",
			"date": "Dates: Summer 2020 - Summer 2021",
			"course": 0,
			"partners": "Mentor/Advisor: Professor Alan Wolf, Chair of Physics at The Cooper Union (ret. 2020)",
			"image": "img/SpringMassChaos.gif",
			"short": "After reaching out the chair of the physics department, I started working on this independent research project as a means to improve my Python skills as I worked to better understand the programming language.",
			"long": "I started this research project with the chair of physics at Cooper during the summer of 2020. A <b><a href='https://en.wikipedia.org/wiki/Chaos_theory'>chaotic</a></b> system is one that is said to have a sensitive dependence on initial conditions. Meaning, a chaotic system would exponentially separate from the path taken by itself for initial conditions that are very similar. The professor and I are interested in seeing if chaotic motion would arise from a small mass (to the left, in my animation) being pulled by a very large mass (on the right, in my animation). The right mass is so massive that it feels no external forces and moves at constant velocity. Meanwhile, the left mass experiences periods of zero velocity while the spring is not exerting enough force to overcome static friction, and periods of motion where the left mass is moving closer to the right mass, which results in the spring being shortened and spring force being reduced until the kinetic friction and spring forces equalize. The professor and I are still working on different models to assess the chaotic qualities of this system, but we have noticed that a difference in initial separations of 1e-6 results in a noticeable difference in the mass's position at different time intervals compared to itself without that initial separation difference. <b><a href='https://youtu.be/fgTVcF3mN3A?t=39'>Here</a></b> is an animation showing the separation difference as a result of the small change in initial conditions. <b><a href='https://youtu.be/y4yQ8tDE9ic'>Here</a></b> is the full video of the animation shown on this page. These animations use <b><a href='https://en.wikipedia.org/wiki/Matplotlib'>Matplotlib</a></b> for graphing and my custom <b><a href='https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods'>Runge-Kutta</a></b> 4th order method for solving the ODEs.",
			"image_description": "Shown: An animated plot of the position and velocity of the two masses with a more representative model at the bottom."
		},
		{
			"id": "doppler",
			"title": "Doppler At-Home Experiment Design",
			"shorttitle": "Doppler Experiment",
			"date": "Semester: Spring 2021",
			"course": "Course: Experimentation",
			"partners": "Partner: Yair G.",
			"image": "img/RawandFFTDoppler.jpeg",
			"short": "I developed an at-home experiment on the Doppler effect that could also be used for in-class/lab demonstrations on the Doppler effect.",
			"long": "As part of my experimentation class, we needed to design our own experiment, with the added twist that it needed to be possible to do at home because of COVID-19. With minimal supplies on hand, I decided to create an at-home experiment that demonstrated the <b><a href='https://en.wikipedia.org/wiki/Doppler_effect'>Doppler effect</a></b>. The experiment involved generating a sound at a known frequency and measuring the frequency as perceived by a stationary microphone. A phone with a frequency app was used as the sound source while a small, <b><a href='https://en.wikipedia.org/wiki/Electret_microphone'>electret microphone</a></b>, monitored by a <b><a href='https://www.pjrc.com/store/teensy41.html'>Teensy 4.1 microcontroller</a></b>, served as the receiver. The movement of the source was controlled by placing it on a small lego cart which was attached via a fishing line to an Arduino-controlled DC motor with an encoder. The experiment consisted of recording the speed using the motor encoder and comparing the linear velocity of the phone to that which was calculated from the Doppler-shifted signal. The shift was determined using Python code that implemented the <b><a href='https://en.wikipedia.org/wiki/Fast_Fourier_transform'>FFT</a></b> on the time-domain data. The results showed a recorded frequency shift that corresponded to the motor angular velocity, with a typical error of approximately 12.6%. The discrepancy was possibly due to encoder issues, but an alternative angular velocity measurement method was not available at the time.",
			"image_description": "Shown: Raw signal and FFT processed signal with a 2000Hz source frequency. The 60Hz FFT peak (far left of FFT) is from the wall-power frequency."
		}
	],
	"projects": [ 
		{
			"id": "eesavior",
			"title": "The EE Savior",
			"shorttitle": "The EE Savior",
			"date": "Semester: Fall 2021",
			"course": "Course: Manufacturing Engineering",
			"partners": "Group Members: Hannah R., Justin H., Kevin D., Brandon H., and Yongjun K.",
			"image": "img/EESaviorInAction.gif",
			"short": "The EE Savior, designed as my final manufacturing engineering project, is a device that cuts, bends, and strips wire to create breadboard jumper cables.",
			"long": "To experience the complexities of designing a manufacturing process, the final manufacturing engineering project was to design and build a device that consistently manufactured a specific product. Knowing how annoying it can be to cut, strip, and bend breadboard jumper wires (such as the ones sold <b><a href='https://www.amazon.com/MCIGICM-Breadboard-Jumper-Cables-Arduino/dp/B081GMJVPB'>here</a></b>), I sought out to design a device that could do just that, in as few steps as possible. Inspired by a <b><a href='https://www.manufacturingguide.com/en/wipe-bending'>wiping die</a></b> used for bending sheet metal, I came up with a method of performing all operations in one step. The wire was easily extruded at the push of a button, which activated the stepper motor containing a 3D printer extruder attachment. A 3D printed spring-loaded fixture would support the wire while it was extruded, clamp it into place, and serve as a guide for the custom-made C.B.S. (cutting, bending, and stripping) component. The C.B.S., which I machined in 3 parts on the manual mill, consisted of a handle, rails for sliding along the main fixture, two stripping & bending edges, and a cutting edge. While the C.B.S. is pressed down along the main fixture, the cutting edge cuts the wire against the feed support block. After that, the two stripping and bending edges catch a part of the insulation, cutting it off, while pushing the legs down against the fixture to bend them. After lifting the C.B.S. back up, the fixture springs open for the wire to be removed, and the process repeated. Due to manufacturing defects, the cutting mechanism did not operate properly, requiring the user to cut the wire with a wire cutter; but a future version could make use of an alternative design that is less error-prone. Click <b><a href='https://drive.google.com/drive/folders/13VK7xedV8jqnkK6Q7OyL0ajrHRkBHBJ_?usp=sharing'>here</a></b> for images of the final project.",
			"image_description": "Shown: A short gif of me using the EE Savior to manufacture a single jumper wire."
		},
		{
			"id": "fsae",
			"title": "Formula SAE",
			"shorttitle": "Formula SAE",
			"date": "Semesters: Fall 2018 - Fall 2021",
			"course": 0,
			"partners": "Partners: The Cooper Motorsports Team",
			"image": "img/FormulaSAESteeringandSuspension.png",
			"short": "I spent 3 years on my school's Formula SAE team designing and building a formula-style racecar. I was a member of the suspension subsystem designing and manufacturing components, the frame subsystem welding together the frame, I served as the steering subsystem lead during the 2019 and 2020 seasons, and the chief engineer during the 2021 season.",
			"long": "Freshman year I went to the Cooper <b><a href='https://en.wikipedia.org/wiki/Formula_SAE'>Formula SAE</a></b> orientation meeting, where I learned about what the team does (build an open-wheel formula-style racecar) and met some of the members; by the end, I had signed up. I have come a long way since my freshman year, now holding the elected position of Chief Engineer, charged with overseeing and verifying all design decisions and ensuring system integration and quality control for all components. Before becoming Chief Engineer, freshman year I joined the vehicle dynamics system and started learning a lot and working hard. I learned about different components, how they all fit and worked together, and helped with manufacturing, learning how to machine on the manual lathe and vertical mill and TIG weld. At the end of freshman year, I took over the steering subsystem as the steering subsystem lead, charged with designing and manufacturing the steering of the car. I continued in that role through sophomore year. Being on the team has been an incredible opportunity to learn practical mechanical engineering skills. Although the in-person 2020 competition in Michigan was canceled due to COVID-19, an online competition was held where I presented the steering design to expert judges. Click <b><a href='http://fsae.cooper.edu/3/'>here</a></b> for a link to the Cooper FSAE website.",
			"image_description": "Shown: The 3D CAD model of the racecar tube frame with the steering assembly and the front left suspension assembly, both of which I worked on."
		},
		{
			"id": "turbofancfd",
			"title": "Gas Turbofan CFD",
			"shorttitle": "Gas Turbofan CFD",
			"date": "Semester: Spring 2021",
			"course": "Course: Computational Fluid Dynamics (graduate-level)",
			"partners": "Partners: Alex S., Brandon H., and William L.",
			"image": "img/GasTurbofan.png",
			"short": "For the final CFD project, my group and I designed and validated a gas turbofan using CFD software.",
			"long": "As the final project of our <b><a href='https://en.wikipedia.org/wiki/Computational_fluid_dynamics'>computational fluid dynamics (CFD)</a></b> class, we were tasked with designing and validating (through CFD simulations) an <b><a href='https://en.wikipedia.org/wiki/Axial_compressor'>axial compressor</a></b>. Before I started, I had no clue how they worked. This class was a graduate-level elective that I took at the end of my Junior because I wanted to learn about CFD solvers and how to use them. The professor for this class, liked giving projects that students did not know how to do when they started, so they could learn as much as possible along the way. My group and I started by reading papers on how axial compressors worked, and watching various videos we found online. We slowly developed extensive Excel spreadsheets that detailed our calculations for the design. We validated and adjusted our design based on the many CFD simulations we ran in <b><a href='https://www.ansys.com/products/fluids/ansys-fluent'>Ansys Fluent</a></b>. In the end, we were able to write an over 40-page technical report describing the design, the calculations, and simulation results we used to validate our decisions. Overall, it was an incredible learning opportunity that gave me more confidence in approaching and tackling problems I had never seen before.",
			"image_description": "Shown: The 3D CAD model of the final axial compressor that we designed and verified using CFD."
		},
		{
			"id": "procsim",
			"title": "Flash Tank Unit Solver",
			"shorttitle": "Flash Tank Solver",
			"date": "Semester: Spring 2021",
			"course": "Course: Numerical Methods (formally: Process Simulation and Mathematical Techniques for Chemical Engineers)",
			"partners": "Partners: None (individual project)",
			"image": "img/flash3flowchart.jpg",
			"short": "For the final project of my numerical methods class, I needed to write Python code that would describe the state as well as input and outputs of the chemical species. Different numerical algorithms were used depending on the inputs.",
			"long": "For the final project of my numerical methods class, I had to create a Python module that implemented various numerical techniques, which would be used to solve for the state of a <b><a href='https://en.wikipedia.org/wiki/Vapor%E2%80%93liquid_separator'>flash tank unit</a></b>. Although the numerical methods class was specifically for chemical engineers (the class was formally called <i>Process Simulation and Mathematical Techniques for Chemical Engineers</i>), the topics were widely applicable. In this class, we learned about numerical error inherent in all calculations and computer simulations, how to avoid and quantify these errors, and how to use various numerical methods to: solve equations, interpolate & extrapolate data, perform numerical differentiation & integration, solve IVPs, systems of nonlinear equations (SNLEs), BVPs, & PDEs, and solve problems iteratively. The class was taught using Python, my favorite programming language, where we learned how to write our own functions for numerical computations and use the functions found in various modules, such as <b><a href='https://en.wikipedia.org/wiki/NumPy'>NumPy</a></b> and <b><a href='https://en.wikipedia.org/wiki/SciPy'>SciPy</a></b>. The final project was broken into 3 parts. The first part was to create functions that solved for the saturation pressure of 4 chemical species provide the error on the results; I did this by fitting each species’ data with two overlapping exponential curves (the shape was dictated by the <b><a href='https://en.wikipedia.org/wiki/Clausius%E2%80%93Clapeyron_relation'>Clausius–Clapeyron relation</a></b>) that were fit by nonlinear least-squares regression. The second part was to create the functions that solved for the state of the flash tank unit given specific inputs, and we needed to use <b><a href='https://en.wikipedia.org/wiki/Root-finding_algorithms'>root finding</a></b>, <b><a href='https://en.wikipedia.org/wiki/Gradient_descent#Solution_of_a_non-linear_system'>gradient descent for SNLEs</a></b>, and <b><a href='https://en.wikipedia.org/wiki/Newton%27s_method#Nonlinear_systems_of_equations'>Newton’s method for SNLEs</a></b>. The last part, which was optional, was to solve PDEs describing the diffusion of hydrogen for the maximum distance a sensor could be placed to detect a leak within a given time interval. I received a perfect score on this project. My code for this project can be found on GitHub <b><a href='https://github.com/jjacobowitz/CHE352_Davis/tree/master/Project'>here</a></b>. My code for this class in general can be found <b><a href='https://github.com/jjacobowitz/CHE352_Davis'>here</a></b>.",
			"image_description": "Shown: A flowchart outlining one of the functions for part 2 of the final project."
		},
		{
			"id": "mdofboat",
			"title": "MDOF Boat Vibration",
			"shorttitle": "MDOF Boat",
			"date": "Semester: Spring 2021",
			"course": "Course: Vibrations",
			"partners": "Partner: Yair G.",
			"image": "img/MDOFBoatMATLAB.gif",
			"short": "As a final project for my vibrations class, we were tasked with analyzing a real-world vibrating system with the tools and methods we had learned during the semester. My partner and I decided to model a 3 degree-of-freedom (DOF) boat on water.",
			"long": "As a final project for my vibrations class, we were tasked with analyzing a real-world vibrating system with the tools and methods we had learned during the semester. My partner and I decided to model a 3 degree-of-freedom (DOF) boat on water. The 3 DOFs we focused on were <b><a href='https://en.wikipedia.org/wiki/Ship_motions'>heave, roll, and pitch</a></b>. We only considered small rotations, allowing for a small angle approximation to be made, and uncoupling the DOFs. Because roll and pitch were both rotational DOFs within the same plane, only one equation needed to be derived and then applied separately for each rotation, with the rotations only different in the geometry of that perspective. In class, we learned to use the <b><a href='https://en.wikipedia.org/wiki/Laplace_transform'>Laplace</a></b> (frequency) domain to analyze vibration systems because it reduces derivatives to linear functions. Using <b><a href='https://www.mathworks.com/products/matlab.html'>MATLAB</a></b>, my partner and I were able to simulate the motion of a boat in response to an imaginary plane of water. We presented our results to our class at the end of the semester.",
			"image_description": "Shown: The boat responding to the motion of a planar wave, causing forced vibrations. The animation was created in MATLAB."
		},
		{
			"id": "slapsteak",
			"title": "Slap-Cooking a Steak",
			"shorttitle": "Steak",
			"date": "Semester: Spring 2021",
			"course": "Course: Heat Transfer",
			"partners": "Partner: YoungWoong C.",
			"image": "img/SteakHeatmap.gif",
			"short": "As a final project for my heat transfer class, we were tasked with analyzing a real-world heat transfer problem with the tools and methods we had learned during the semester. My partner and I decided to see how many slaps it would take to cook a steak (to medium-rare).",
			"long": "As a final project for my heat transfer class, we were tasked with analyzing a real-world heat transfer problem with the tools and methods we had learned during the semester. My partner and I decided to see how many slaps it would take to cook a steak (to medium-rare). This idea came from an internet meme where someone asked on Reddit how many slaps it would take to cook a chicken. We decided to look at a steak instead because a sirloin medallion steak is cylindrically shaped, making it simple to analyze. In Python, we discretized the steak into radial shells. The heat flow through the steak was modeled using the thermal capacity of the steak and the approximate energy of a slap. We created heatmap animations of the steak to see the cooking progress. In the end, we found that it would take around 156000; at one slap every three-quarters of a second, it would take around 2.4 days of continuous slapping.",
			"image_description": "Shown: The animated steak heatmap (created in Python) showing the cooking progress at different cross-sections."
		},
		{
			"id": "turbinefea",
			"title": "Wind Turbine FEA",
			"shorttitle": "Wind Turbine FEA",
			"date": "Semester: Fall 2020",
			"course": "Course: Computer-Aided Engineering (graduate-level)",
			"partners": "Partners: Alex S., Brandon H., and William L.",
			"image": "img/WindTurbineExtremeStress.png",
			"short": "For the midterm project in my CAE course, my group and I designed and validated, using Ansys FEA software (APDL and workbench), a wind turbine tower and baseplate that would withstand the various loading conditions posed by the problem statement.",
			"long": "For my <b><a href='https://en.wikipedia.org/wiki/Computer-aided_engineering'>computer-aided engineering (CAE)</a></b> midterm project, I was tasked with designing and validating (via FEA simulations) a <b><a href='https://en.wikipedia.org/wiki/Wind_turbine'>wind turbine</a></b> tower and baseplate that would withstand a given set of loading conditions. Knowing this project would be time-consuming, I arranged for my group to meet right after the class to discuss our initial thoughts. We sketched out some ideas and I ended the meeting with a plan on how our group would tackle this project. Over the next month, we would meet weekly to go over hand calculations, new ideas to improve our designs, and simulation results (all performed in <b><a href='https://www.ansys.com/products/structures/ansys-mechanical'>Ansys APDL and Workbench</a></b>). We slowly developed a tower design that was supported by our calculations and simulations and applied the tower reaction loads to baseplate simulations. I remember personally running over 10 different simulations in a single day to test different baseplate designs, making use of symmetries to reduce model complexity and simulation time. In the end, we wrote a comprehensive 40-page technical report detailing our design and backing it up with FEA results. Through this project, I became more familiar with the iterative FEA simulation and design process, and better understood the uses and limitations of the software.",
			"image_description": "Shown: The Ansys APDL tower stress contour plot when loading the tower with the most extreme loading conditions."
		},
		{
			"id": "piapproxdarts",
			"title": "Pi Approximation Using \"Darts\"",
			"shorttitle": "Pi Approximation",
			"date": "Date: Summer 2020",
			"course": 0,
			"partners": "Partners: None (personal project)",
			"image": "img/PiApproximationWhiteBackground.png",
			"short": "I wrote some short C++ code to calculate Pi based on a randomized \"dart throw\", comparing the number of darts thrown to those that landed within the unit circle.",
			"long": "Once again, a YouTube video was my inspiration for a project. I first heard about this method of calculating Pi from <b><a href='https://www.youtube.com/watch?v=M34TO71SKGk'>this</a></b> video. Given a circle inscribed in a square, if darts are randomly thrown at this \"board\", most will land in the circle, and some will land in the small region that the circle does not cover. Given the area of the circle is pi * radius^2, and the area of the square (whose side length would be 2 * radius if a circle is inscribed within it)is 4 * radius^2, the probability of a dart landing within the circle is pi * radius^2 / 4 * radius^2 = pi/4. Multiplying by 4, we can find the approximate value of Pi. With only a few darts thrown, the approximation for Pi would not be very close to the actual value. But after many darts are thrown, the value will get closer and closer. The code for this can be found on my GitHub <b><a href='https://github.com/jjacobowitz/PiApproximation'>here</a></b>.",
			"image_description": "Shown: The code input and output, which compares the calculated value of Pi to the actual value (rounded to 16 decimal places)."
		},
		{
			"id": "chaosgame",
			"title": "Chaos Game",
			"shorttitle": "Chaos Game",
			"date": "Date: Summer 2020",
			"course": 0,
			"partners": "Partners: None (personal project)",
			"image": "img/ChaosGame.gif",
			"short": "I wrote Python code to simulate the <b><a href='https://en.wikipedia.org/wiki/Chaos_game'>Chaos Game</a></b>, a simple game where, from randomized selections, a Sierpiński triangle emerges.",
			"long": "I originally saw a <b><a href='https://youtu.be/kbKtFN71Lfs'>Numberphile</a></b> video about the <b><a href='https://en.wikipedia.org/wiki/Chaos_game'>Chaos Game</a></b> on YouTube. Rules: given a starting point, a vertex is randomly selected, and the new point is half the distance between the current point and the vertex. When starting with 3 vertices, a <b><a href='https://en.wikipedia.org/wiki/Sierpi%C5%84ski_triangle'>Sierpiński triangle</a></b> emerges. I wrote the code for this in Python and used <b><a href='https://matplotlib.org/'>Matplotlib</a></b> to create the visuals. Animating and exporting the plot as a gif proved to be challenging, but I learned a lot for future animated projects. My code for this project can be found <b><a href='https://github.com/jjacobowitz/ChaosGame'>here</a></b>.",
			"image_description": "Shown: The animated output (from Python) of the chaos game, which shows the Sierpiński triangle developing."
		},
		{
			"id": "eigenproblem",
			"title": "Eigenproblem",
			"shorttitle": "Eigenproblem",
			"date": "Date: Summer 2020",
			"course": 0,
			"partners": "Partners: None (personal project)",
			"image": "img/EigenproblemPhasePortrait.png",
			"short": "I wrote an explanation of how to solve the eigenproblem to better familiarize myself with the problem and solution method.",
			"long": "After learning in my \"Systems Dynamics\" class about the response of a system using differential equations, we extended this to more dimensions. The natural language of performing these calculations is linear algebra. To find the behavior of the system, we solved for the <b><a href='https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors'>eigenvalues and eigenvectors</a></b>. To better visualize this, I created this plot. Shown here is the phase portrait showing the system response to some initial conditions. I wrote <b><a href='https://drive.google.com/open?id=18-BsFYriYZPJ-sc3_Y66BBpB_YV0_x3A'>this</a></b> LaTeX document to explain math behind the eigenproblem, working through the example shown. The code for this can be found on my GitHub <b><a href='https://github.com/jjacobowitz/EigenvaluesandEigenvectos'>here</a></b>.",
			"image_description": "Shown: A plot of the phase portrait with the system response to some initial conditions."
		},
		{
			"id": "homegarden",
			"title": "Garden for my Mom",
			"shorttitle": "Home Garden",
			"date": "Date: Summer 2020",
			"course": 0,
			"partners": "Partners: None (personal project)",
			"image": "img/GardenPhotoSummer2020.jpg",
			"short": "During COVID-19, I designed a garden for my mother and built it with my father. My mother plants her vegetables in the garden to keep out the animals that like to snack on her crops.",
			"long": "My mother loves gardening, but the animals were becoming too much. Where I live, we have: squirrels, chipmunks, rabbits, mice, raccoons, skunks, deer, foxes, and groundhogs. All these animals enjoy my mother’s vegetables as much as she does. So, during the summer of 2020, she asked for a fenced-in garden. I drew up some plans (see a photo of them <b><a href='https://drive.google.com/file/d/1s5vVlr4jvMBybIbBk8BTmBHu5Hv2pnKE/view?usp=sharing'>here</a></b>) and bought all the materials with my father. Over the course of 5 days, my father and I built the garden. The garden has four 2\"x8\" planks that skirt the perimeter, making the 6'x10' base. There are seven 2\"x4\"x6' pieces that make up the vertical posts, all of which are dug half a foot into the ground. Connecting all the vertical supports are 1\"x2\"s. On the bottom, we lay down ¼\" hardware cloth (steel fencing that has ¼\" holes) to keep animals from burrowing underneath. We then put down a tarp to prevent weeds and filled the garden with about 30 cubic feet of organic garden soil. Around the perimeter, we stapled more ¼\" hardware cloth to prevent animals from getting in. The perimeter fence extends 6' high to prevent deer from reaching over and feasting. The door is easily attached and removed with eye-hooks and is also covered in ¼\" hardware cloth. So far the garden has kept out all animals, leaving the plants to grow freely. For photos of the garden throughout the process, follow <b><a href='https://drive.google.com/drive/folders/1ag74wSXPwJwtQMppAqDI7BzOLjBzVhN5?usp=sharing'>this</a></b> link to a Google Drive folder.",
			"image_description": "Shown: The completed garden with my mother's summer 2020 crop growing nicely."
		},
		{
			"id": "modelcvt",
			"title": "Continuous Variable Transmission",
			"shorttitle": "Model CVT",
			"date": "Semester: Fall 2019",
			"course": "Course: Cloud-Based Design and Manufacturing",
			"partners": "Group Members: Dean C., Connor L., Flora S., and Eric W.",
			"image": "img/CVTRunning.gif",
			"short": "Tasked with designing a small and easily adjustable transmission for my \"Cloud-Based Design and Manufacturing\" class, my team and I made a <b><a href='https://en.wikipedia.org/wiki/Continuously_variable_transmission#Toroidal_or_roller-based_(Extroid)'>toroidal CVT</a></b>.",
			"long": "Tasked with designing a small and easily adjustable transmission for my \"Cloud-Based Design and Manufacturing\" class, my team and I made a <b><a href='https://en.wikipedia.org/wiki/Continuously_variable_transmission#Toroidal_or_roller-based_(Extroid)'>toroidal CVT</a></b>. It was made from 3D printed, laser-cut acrylic, CNC’d, and a few purchased parts. The CVT works with 3 different motors using custom motor mounts. My team and I worked together using <b><a href='https://en.wikipedia.org/wiki/Onshape'>Onshape</a></b> CAD software. The professor said every other group's transmission eventually failed, but ours ran for over an hour before he stopped it. Pictures and some failed tests can be found <b><a href='https://drive.google.com/open?id=1nUAFT8Wc2R4QqrLg0eJn9B2ebOWrDnIv'>here</a></b>.",
			"image_description": "Shown: A test run of the fully-built CVT with the side cover removed to show the inner workings."
		},
		{
			"id": "patienceegg",
			"title": "The Patience Egg",
			"shorttitle": "Patience Egg",
			"date": "Semester: Spring 2019",
			"course": "Course: Principles of Design",
			"partners": "Group Members: Caitlin R., Eunkyu K., and Seyun K.",
			"image": "img/PatienceEgg.jpg",
			"short": "A puzzle egg is an egg-shaped puzzle. I designed and built a puzzle egg that rewards those who are patient.",
			"long": "This puzzle egg (i.e. a puzzle shaped like an egg) is designed to reward those who are patient.  Using an <b><a href='https://www.adafruit.com/product/2809'>accelerometer</a></b>, the <b><a href='https://www.arduino.cc/en/pmwiki.php?n=Main/ArduinoBoardNano'>Arduino Nano</a></b> keeps track of the time since it was moved last. After the specified time has elapsed, the <b><a href='https://www.adafruit.com/product/169'>servomotor</a></b> is triggered, allowing the egg to be opened. The shell was designed in SolidWorks and simple models of the components were made and \"test fit\" to validate the size. To avoid false readings, the <i>xyz</i> accelerations are averaged, and three successive readings above the movement threshold are needed to reset the timer. More photos of this project can be found <b><a href='https://drive.google.com/open?id=1NFVUlzr-LKPWqc4V0paeqsQUuHEnLaVh'>here</a></b> and GitHub <b><a href='https://github.com/jjacobowitz/PatienceEgg'>here</a></b>.",
			"image_description": "Shown: A view inside the egg showing the accelerometer, Arduino Nano, servomotor, and battery clip."
		}
	]
}